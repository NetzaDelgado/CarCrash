<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Prueba de Choque</title>
    <!-- Incluimos Tailwind CSS para el diseño -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Importamos la fuente Inter de Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Evitar scroll */
        }
        canvas {
            background-color: #374151; /* bg-gray-700 */
            touch-action: none; /* Previene el scroll en móvil al tocar el canvas */
            width: 100%;
            height: 100%;
        }
        /* Estilo para los botones de control */
        .control-button {
            transition: all 0.1s ease;
            user-select: none; /* Evitar selección de texto */
            -webkit-user-select: none;
            touch-action: manipulation; /* Mejor respuesta táctil */
        }
        .control-button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4 md:p-8">

    <div class="w-full max-w-7xl mx-auto">
        
        <h1 class="text-3xl font-bold text-center mb-4 text-yellow-400">Simulador de Física de Colisión</h1>

        <!-- Panel de Indicadores y Controles -->
        <div class="bg-gray-800 p-4 rounded-xl shadow-2xl mb-4 grid grid-cols-2 md:grid-cols-4 gap-4">
            
            <!-- Indicadores -->
            <div class="bg-gray-900 p-4 rounded-lg text-center">
                <span class="text-sm font-medium text-gray-400">Velocidad</span>
                <p id="velocityValue" class="text-2xl font-bold text-white">0.0 m/s</p>
            </div>
            <div class="bg-gray-900 p-4 rounded-lg text-center">
                <span class="text-sm font-medium text-gray-400">Fuerza Aplicada</span>
                <p id="forceValue" class="text-2xl font-bold text-white">0 N</p>
            </div>
            <div class="bg-gray-900 p-4 rounded-lg text-center">
                <span class="text-sm font-medium text-gray-400">Energía de Impacto</span>
                <p id="energyValue" class="text-2xl font-bold text-red-500">- J</p>
            </div>
            
            <!-- Controles -->
            <div class="col-span-2 md:col-span-1 grid grid-cols-3 gap-2">
                <button id="accelerate" class="control-button bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-4 rounded-lg shadow-lg col-span-1">
                    ACEL
                </button>
                <button id="brake" class="control-button bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-4 rounded-lg shadow-lg col-span-1">
                    FRENO
                </button>
                <button id="reset" class="control-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-lg col-span-1">
                    RESET
                </button>
            </div>
        </div>

        <!-- Contenedor del Canvas -->
        <div class="w-full h-[300px] md:h-[400px] border-4 border-yellow-500 rounded-lg overflow-hidden shadow-2xl">
            <canvas id="crashCanvas"></canvas>
        </div>
        
    </div>

    <script>
        // --- Configuración del Canvas ---
        const canvas = document.getElementById('crashCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- Controles y Displays ---
        const accelerateBtn = document.getElementById('accelerate');
        const brakeBtn = document.getElementById('brake');
        const resetBtn = document.getElementById('reset');
        
        const velocityValue = document.getElementById('velocityValue');
        const forceValue = document.getElementById('forceValue');
        const energyValue = document.getElementById('energyValue');

        // --- Constantes de Física ---
        const GRAVITY = 0.5;
        const BOUNCE = 0.3; // Factor de rebote bajo
        const AIR_FRICTION = 0.995; // Fricción del aire
        const GROUND_FRICTION = 0.95; // Fricción del suelo
        const STICK_ITERATIONS = 7; // Rigidez de la simulación
        
        // --- Constantes del Simulador ---
        const PIXEL_TO_METER = 0.05; // 1 píxel = 5 cm
        const UPDATES_PER_SECOND = 60; // Asumimos 60 FPS para cálculos
        const ACCELERATION_FORCE = 30000; // Fuerza del motor en Newtons
        const BRAKE_FORCE = -60000; // Fuerza de frenado en Newtons
        const CAR_MASS = 1500; // Masa total del coche en kg (para cálculos de F=ma y KE)
        
        // --- Variables Globales de Simulación ---
        let particles = [];
        let sticks = [];
        let debris = [];
        
        let car = null;
        let wallX = 0;
        let groundY = 0;
        
        let isAccelerating = false;
        let isBraking = false;
        let hasImpacted = false;
        let impactEnergy = 0;

        // --- Variables de Cámara ---
        let cameraZoom = 0.7;
        let cameraX = 0;
        let cameraY = 0;

        // --- Clases de Física ---
        class Particle {
            constructor(x, y, oldX, oldY, mass = 1.0, isFixed = false, group = 'default', radius = 3) {
                this.x = x;
                this.y = y;
                this.old_x = oldX;
                this.old_y = oldY;
                this.mass = mass;
                this.isFixed = isFixed;
                this.group = group; // 'car', 'wall', 'debris'
                this.radius = radius;
                // Propiedades para el coche
                this.isWheel = false;
                this.wheelRadius = 0;
                this.wheelAngle = 0;
            }
            
            // Aplicar fuerza (F=ma -> a=F/m -> v_new = v_old + a*dt)
            applyForce(fx, fy) {
                if (this.isFixed) return;
                const dt = 1 / UPDATES_PER_SECOND;
                // a = F/m
                const ax = fx / this.mass;
                const ay = fy / this.mass;
                
                // v_new = v_old + a*dt  => (x - old_x) + a*dt
                // Para mantener la simulación estable, aplicamos el cambio a old_x
                this.old_x -= ax * dt;
                this.old_y -= ay * dt;
            }
        }

        class Stick {
            constructor(p1, p2, length, isBreakable = false, breakThreshold = 2.0) {
                this.p1 = p1; // index of particle 1
                this.p2 = p2; // index of particle 2
                this.length = length;
                this.isBreakable = isBreakable;
                this.breakThreshold = breakThreshold; // Multiplicador de longitud (ej: 2.0 = se rompe al 200% de longitud)
                this.isBroken = false;
            }
        }

        // --- Clase del Coche ---
        class Car {
            constructor(startX, startY) {
                this.particles = []; // Partículas que componen el coche
                this.sticks = []; // Palos que componen el coche
                
                // Propiedades del coche
                this.particleMass = 10;
                const carHeight = 30;
                const chassisLength = 100;
                const wheelRadius = 15;

                // Crear partículas del chasis (partículas 0-3)
                // 0: Front-Top, 1: Front-Bottom (Bumper), 2: Rear-Bottom, 3: Rear-Top
                this.particles.push(new Particle(startX + chassisLength, startY, startX + chassisLength, startY, this.particleMass, false, 'car', 3));
                this.particles.push(new Particle(startX + chassisLength, startY + carHeight, startX + chassisLength, startY + carHeight, this.particleMass, false, 'car', 3));
                this.particles.push(new Particle(startX, startY + carHeight, startX, startY + carHeight, this.particleMass * 2, false, 'car', 3)); // Más masa atrás
                this.particles.push(new Particle(startX, startY, startX, startY, this.particleMass * 2, false, 'car', 3));
                
                // Partículas de las ruedas (partículas 4-5)
                const frontWheelX = startX + chassisLength - wheelRadius - 10;
                const rearWheelX = startX + wheelRadius + 10;
                const wheelY = startY + carHeight + wheelRadius;
                
                this.particles.push(new Particle(frontWheelX, wheelY, frontWheelX, wheelY, this.particleMass * 0.5, false, 'car', wheelRadius));
                this.particles.push(new Particle(rearWheelX, wheelY, rearWheelX, wheelY, this.particleMass * 0.5, false, 'car', wheelRadius));
                
                // Marcar ruedas
                this.particles[4].isWheel = true;
                this.particles[4].wheelRadius = wheelRadius;
                this.particles[5].isWheel = true;
                this.particles[5].wheelRadius = wheelRadius;

                // Añadir partículas extra al parachoques para deformación (partículas 6-7)
                this.particles.push(new Particle(startX + chassisLength + 10, startY + 5, startX + chassisLength + 10, startY + 5, this.particleMass * 0.2, false, 'car', 3));
                this.particles.push(new Particle(startX + chassisLength + 10, startY + carHeight - 5, startX + chassisLength + 10, startY + carHeight - 5, this.particleMass * 0.2, false, 'car', 3));

                // Añadir partículas al array global
                const offset = particles.length;
                particles.push(...this.particles);

                // Conectar partículas del chasis con palos
                const breakableThreshold = 1.15; // Se rompe al 115% de longitud
                
                // Chasis exterior (rígido)
                this.sticks.push(new Stick(offset + 0, offset + 1, carHeight));
                this.sticks.push(new Stick(offset + 1, offset + 2, chassisLength));
                this.sticks.push(new Stick(offset + 2, offset + 3, carHeight));
                this.sticks.push(new Stick(offset + 3, offset + 0, chassisLength));
                
                // Soportes internos (rígidos)
                this.sticks.push(new Stick(offset + 0, offset + 2, Math.hypot(chassisLength, carHeight)));
                this.sticks.push(new Stick(offset + 1, offset + 3, Math.hypot(chassisLength, carHeight)));

                // Conectar ruedas (rompibles)
                this.sticks.push(new Stick(offset + 1, offset + 4, Math.hypot(10, wheelRadius), true, 1.5));
                this.sticks.push(new Stick(offset + 2, offset + 5, Math.hypot(10, wheelRadius), true, 1.5));
                
                // Conectar parachoques deformable (muy rompible)
                this.sticks.push(new Stick(offset + 0, offset + 6, 11.18, true, breakableThreshold));
                this.sticks.push(new Stick(offset + 6, offset + 7, carHeight - 10, true, breakableThreshold));
                this.sticks.push(new Stick(offset + 7, offset + 1, 11.18, true, breakableThreshold));
                
                // Añadir palos al array global
                sticks.push(...this.sticks);
            }
            
            // Método para aplicar fuerza al coche
            applyForce(fx, fy) {
                // Aplicar fuerza a las partículas traseras (tracción trasera)
                this.particles[2].applyForce(fx, fy);
                this.particles[3].applyForce(fx, fy);
            }
        }

        // --- Funciones de Simulación ---

        function init() {
            // Ajustar el tamaño del canvas
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // Definir límites del "MUNDO"
            wallX = 1500; // Muro a la derecha (más lejos)
            groundY = 500; // Suelo (más abajo para centrar)
            
            // Limpiar arrays
            particles = [];
            sticks = [];
            debris = [];
            
            // Resetear estado
            isAccelerating = false;
            isBraking = false;
            hasImpacted = false;
            impactEnergy = 0;
            
            // Crear el coche (con más espacio inicial)
            car = new Car(100, groundY - 60);
            
            // Construir la pared
            buildWall(wallX, groundY, 4, 15, 12); // (startX, startY, numNodesX, numNodesY, nodeSpacing)
            
            // Configurar la cámara para centrar el mundo
            cameraZoom = 0.7; // Zoom out
            cameraX = wallX / 2; // Centrar horizontalmente
            cameraY = groundY / 2; // Centrar verticalmente
            
            // Actualizar UI
            updateUI(0, 0);
            velocityValue.textContent = "0.0 m/s";
            forceValue.textContent = "0 N";
            energyValue.textContent = "- J";
        }
        
        function buildWall(startX, startY, numNodesX, numNodesY, nodeSpacing) {
            let wallParticles = []; // Array 2D para guardar partículas y encontrar vecinos
            const wallMass = 50; // Masa de cada partícula de la pared
            const breakThreshold = 1.1; // Límite de ruptura bajo
            const radius = nodeSpacing / 2;

            for (let y = 0; y < numNodesY; y++) {
                wallParticles[y] = [];
                for (let x = 0; x < numNodesX; x++) {
                    const px = startX + x * nodeSpacing;
                    const py = startY - y * nodeSpacing - (nodeSpacing / 2); // Empezar a construir desde el suelo
                    
                    // Crear partícula
                    const p = new Particle(px, py, px, py, wallMass, false, 'wall', radius);
                    
                    // Anclar la fila inferior al suelo
                    if (y === 0) {
                        p.isFixed = true;
                    }
                    
                    wallParticles[y][x] = p;
                    particles.push(p);
                }
            }

            // Conectar partículas de la pared con palos
            for (let y = 0; y < numNodesY; y++) {
                for (let x = 0; x < numNodesX; x++) {
                    const p_idx = particles.indexOf(wallParticles[y][x]);

                    // Conectar a la partícula de la izquierda
                    if (x > 0) {
                        const left_p_idx = particles.indexOf(wallParticles[y][x - 1]);
                        sticks.push(new Stick(p_idx, left_p_idx, nodeSpacing, true, breakThreshold));
                    }
                    
                    // Conectar a la partícula de abajo
                    if (y > 0) {
                        const bottom_p_idx = particles.indexOf(wallParticles[y - 1][x]);
                        sticks.push(new Stick(p_idx, bottom_p_idx, nodeSpacing, true, breakThreshold));
                    }
                    
                    // Conectar en diagonal (para rigidez)
                    if (x > 0 && y > 0) {
                        const diag_p_idx = particles.indexOf(wallParticles[y - 1][x - 1]);
                        sticks.push(new Stick(p_idx, diag_p_idx, Math.sqrt(2 * nodeSpacing * nodeSpacing), true, breakThreshold));
                    }
                     // Conectar otra diagonal
                    if (x < numNodesX - 1 && y > 0) {
                        const diag_p_idx = particles.indexOf(wallParticles[y - 1][x + 1]);
                        sticks.push(new Stick(p_idx, diag_p_idx, Math.sqrt(2 * nodeSpacing * nodeSpacing), true, breakThreshold));
                    }
                }
            }
        }

        function updatePhysics() {
            // Aplicar fuerzas (Motor/Frenos)
            let appliedForce = 0;
            if (isAccelerating && !hasImpacted) {
                car.applyForce(ACCELERATION_FORCE / (car.particles.length / 2), 0);
                appliedForce = ACCELERATION_FORCE;
            }
            if (isBraking && !hasImpacted) {
                car.applyForce(BRAKE_FORCE / (car.particles.length / 2), 0);
                appliedForce = BRAKE_FORCE;
            }

            // Actualizar Partículas (Gravedad, Fricción)
            let total_vx = 0;
            let carParticleCount = 0;
            
            for (const p of particles) {
                if (p.isFixed) continue;
                
                // Calcular velocidad
                let vx = (p.x - p.old_x) * AIR_FRICTION;
                let vy = (p.y - p.old_y) * AIR_FRICTION;
                
                // Gravedad
                vy += GRAVITY;
                
                // Guardar posición anterior
                p.old_x = p.x;
                p.old_y = p.y;
                
                // Mover
                p.x += vx;
                p.y += vy;
                
                // Sumar velocidad (para UI)
                if (p.group === 'car') {
                    total_vx += vx;
                    carParticleCount++;
                }
            }
            
            // Actualizar UI con velocidad promedio
            const avg_vx = (carParticleCount > 0) ? (total_vx / carParticleCount) : 0;
            updateUI(avg_vx, appliedForce);
            
            // Actualizar Escombros
            for (const d of debris) {
                d.ttl--;
                let vx = (d.x - d.old_x);
                let vy = (d.y - d.old_y);
                vy += GRAVITY; // Gravedad en escombros
                
                d.old_x = d.x;
                d.old_y = d.y;
                d.x += vx;
                d.y += vy;
                
                // Colisión de escombros con el suelo
                if (d.y > groundY) {
                    d.y = groundY;
                    d.old_y = d.y + vy * BOUNCE;
                }
            }
            
            // Filtrar escombros muertos
            debris = debris.filter(d => d.ttl > 0);
        }

        function resolveCollisions() {
            // Bucle O(n^2) simple para colisión partícula-partícula
            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                if (p1.isFixed) continue;

                for (let j = i + 1; j < particles.length; j++) {
                    const p2 = particles[j];
                    
                    // No colisionar partículas del mismo grupo (ej. dos partículas del coche entre sí)
                    if (p1.group === p2.group) continue;
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distSq = dx * dx + dy * dy;
                    const totalRadius = p1.radius + p2.radius;
                    
                    // Si están colisionando
                    if (distSq < totalRadius * totalRadius) {
                        const dist = Math.sqrt(distSq);
                        const overlap = (totalRadius - dist);
                        
                        // Vector de separación (normalizado)
                        const sepX = (dx / dist) * overlap;
                        const sepY = (dy / dist) * overlap;
                        
                        // Moverlas basado en su masa
                        const totalMass = p1.mass + p2.mass;
                        const p1_move = p2.isFixed ? 1 : (p2.mass / totalMass);
                        const p2_move = p1.isFixed ? 1 : (p1.mass / totalMass);

                        p1.x -= sepX * p1_move;
                        p1.y -= sepY * p1_move;
                        
                        if (!p2.isFixed) {
                            p2.x += sepX * p2_move;
                            p2.y += sepY * p2_move;
                        }
                        
                        // Detectar impacto (si el coche golpea la pared)
                        if (!hasImpacted && 
                            (p1.group === 'car' && p2.group === 'wall') || 
                            (p1.group === 'wall' && p2.group === 'car')) 
                        {
                            const vx = (p1.x - p1.old_x) - (p2.x - p2.old_x);
                            const impactVel = Math.abs(vx);
                            if (impactVel > 1.0) {
                                triggerImpact(impactVel);
                            }
                        }
                    }
                }
            }
        }

        function updateSticks() {
            for (let iter = 0; iter < STICK_ITERATIONS; iter++) {
                for (const s of sticks) {
                    if (s.isBroken) continue;
                    
                    const p1 = particles[s.p1];
                    const p2 = particles[s.p2];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const diff = s.length - dist;
                    const percent = diff / dist / 2;
                    
                    const offsetX = dx * percent;
                    const offsetY = dy * percent;

                    if (!p1.isFixed) {
                        p1.x -= offsetX;
                        p1.y -= offsetY;
                    }
                    if (!p2.isFixed) {
                        p2.x += offsetX;
                        p2.y += offsetY;
                    }
                    
                    // Romper palo si se estira demasiado
                    if (s.isBreakable && (dist > s.length * s.breakThreshold)) {
                        s.isBroken = true;
                        
                        // Crear escombros al romperse
                        const avg_vx = ((p1.x - p1.old_x) + (p2.x - p2.old_x)) / 2;
                        const avg_vy = ((p1.y - p1.old_y) + (p2.y - p2.old_y)) / 2;
                        createDebris((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, 5, avg_vx, avg_vy);
                    }
                }
            }
        }

        function constrain() {
            for (const p of particles) {
                if (p.isFixed) continue;
                
                let vx = (p.x - p.old_x);
                let vy = (p.y - p.old_y);

                // Colisión con el suelo
                if (p.y > groundY) {
                    p.y = groundY;
                    p.old_y = p.y + vy * BOUNCE;
                    // Aplicar fricción del suelo solo si está en el suelo
                    p.old_x = p.x - vx * GROUND_FRICTION;
                }
                
                // Colisión con la pared izquierda
                if (p.x < 0) {
                    p.x = 0;
                    p.old_x = p.x + vx * BOUNCE;
                }
                // Colisión con el techo
                if (p.y < 0) {
                    p.y = 0;
                    p.old_y = p.y + vy * BOUNCE;
                }
            }
        }
        
        // Nueva función para centralizar la lógica de impacto
        function triggerImpact(impactVelocity) {
            if (hasImpacted) return; // Solo impactar una vez

            hasImpacted = true;
            isAccelerating = false;
            isBraking = false;
            
            // Calcular Energía Cinética: KE = 0.5 * m * v^2
            // v en m/s = vx_pixels * PIXEL_TO_METER * UPDATES_PER_SECOND
            const v_ms = impactVelocity * PIXEL_TO_METER * UPDATES_PER_SECOND;
            impactEnergy = 0.5 * CAR_MASS * (v_ms * v_ms);
            
            // Crear una explosión de escombros en el frontal del coche
            createDebris(car.particles[0].x, car.particles[0].y, 20, -impactVelocity * 0.5, 0);
            createDebris(car.particles[1].x, car.particles[1].y, 20, -impactVelocity * 0.5, 0);
        }

        function createDebris(x, y, count, baseVx, baseVy) {
             for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                const vx = Math.cos(angle) * speed + baseVx;
                const vy = Math.sin(angle) * speed + baseVy;
                // Partícula(x, y, oldX, oldY, mass, isFixed)
                const debrisParticle = new Particle(x, y, x - vx, y - vy, 0.1, false, 'debris', 2);
                debrisParticle.ttl = Math.random() * 60 + 60; // Tiempo de vida
                debris.push(debrisParticle);
            }
        }

        function draw() {
            // Limpiar el canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // --- Aplicar Cámara ---
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-cameraX, -cameraY);
            
            // Dibujar suelo (en coordenadas del mundo)
            ctx.fillStyle = '#1F2937'; // bg-gray-800
            ctx.fillRect(0, groundY, wallX + 500, 500); // Dibujar un suelo grande
            
            // Dibujar palos (Sticks)
            ctx.lineWidth = 2;
            for (const s of sticks) {
                if (s.isBroken) continue;
                const p1 = particles[s.p1];
                const p2 = particles[s.p2];
                
                // Colorear palos de la pared de rojo
                if (p1.group === 'wall' && p2.group === 'wall') {
                    ctx.strokeStyle = '#B91C1C'; // red-700
                } else {
                    ctx.strokeStyle = s.isBreakable ? '#FCD34D' : '#D1D5DB'; // Amarillo (rompible), Gris (chasis)
                }

                if (s.isBreakable && hasImpacted && (p1.group === 'car' || p2.group === 'car')) {
                    ctx.strokeStyle = '#EF4444'; // Rojo (impactado)
                }
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }

            // Dibujar Partículas
            for (const p of particles) {
                if (p.isWheel) {
                    // Dibujar Rueda
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#4B5563'; // gray-600
                    ctx.fill();
                    
                    // Dibujar radio para ver rotación
                    const vx = (p.x - p.old_x);
                    p.wheelAngle += vx * 0.1; // Rotar basado en velocidad
                    
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + Math.cos(p.wheelAngle) * p.radius, p.y + Math.sin(p.wheelAngle) * p.radius);
                    ctx.strokeStyle = '#9CA3AF'; // gray-400
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.lineWidth = 2; // reset
                    
                } else if (p.group === 'wall') {
                    // Dibujar partícula de la pared (como un ladrillo)
                    ctx.fillStyle = '#DC2626'; // red-600
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Dibujar articulación del coche
                    ctx.fillStyle = '#3B82F6'; // Azul
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Dibujar Escombros
            ctx.fillStyle = '#F59E0B'; // amber-500
            ctx.globalAlpha = 0.8;
            for (const d of debris) {
                ctx.globalAlpha = d.ttl / 120; // Fade out
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // --- Restaurar Canvas ---
            ctx.restore();
        }

        function updateUI(avg_vx, appliedForce) {
            // v en m/s = vx_pixels * PIXEL_TO_METER * UPDATES_PER_SECOND
            const v_ms = avg_vx * PIXEL_TO_METER * UPDATES_PER_SECOND;
            velocityValue.textContent = `${v_ms.toFixed(1)} m/s`;
            
            forceValue.textContent = `${Math.round(appliedForce)} N`;
            
            if (hasImpacted) {
                energyValue.textContent = `${(impactEnergy / 1000).toFixed(1)} kJ`;
            }
        }

        // --- Bucle Principal del Juego ---
        function gameLoop() {
            updatePhysics();
            resolveCollisions(); // Nueva etapa de colisión
            updateSticks();
            constrain();
            draw();
            
            requestAnimationFrame(gameLoop);
        }

        // --- Manejadores de Eventos ---
        
        // Eventos de ratón
        accelerateBtn.addEventListener('mousedown', () => isAccelerating = true);
        accelerateBtn.addEventListener('mouseup', () => isAccelerating = false);
        accelerateBtn.addEventListener('mouseleave', () => isAccelerating = false);
        
        brakeBtn.addEventListener('mousedown', () => isBraking = true);
        brakeBtn.addEventListener('mouseup', () => isBraking = false);
        brakeBtn.addEventListener('mouseleave', () => isBraking = false);
        
        // Eventos táctiles (para móvil)
        accelerateBtn.addEventListener('touchstart', (e) => { e.preventDefault(); isAccelerating = true; });
        accelerateBtn.addEventListener('touchend', (e) => { e.preventDefault(); isAccelerating = false; });
        
        brakeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); isBraking = true; });
        brakeBtn.addEventListener('touchend', (e) => { e.preventDefault(); isBraking = false; });
        
        // Evento de Reset
        resetBtn.addEventListener('click', init);
        
        // Reiniciar si la ventana cambia de tamaño
        window.addEventListener('resize', init);

        // --- Iniciar Simulación ---
        init();
        gameLoop();
    </script>
</body>
</html>


